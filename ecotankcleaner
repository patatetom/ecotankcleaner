#!/usr/bin/bash


# this bash script allows you to check and clean the print heads of an
# Epson EcoTank 2710 printer accessible via network (USB not supported).
# the data sent to the printer (using the netsend function below) was collected
# using tshark tool (listening to the Epson utility installed on Windows).
# tests have only been performed on the 2710 model : please let me know via
# an new issue if the script works on another model ;-)


# use python
netsend() {
	python3 -c "

import socket, sys
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('${ecotank}', 9100))
s.send(sys.stdin.buffer.read())
s.close()

	"
}


# use bash
# comment next line to use python insteed of bash pseudo-device
netsend() { cat ->/dev/tcp/${ecotank}/9100; }


# uncomment next line to use socat
# netsend() { socat -4 -u STDIN TCP:${ecotank}:9100; }
# uncomment next line to use netcat-openbsd
# netsend() { echo netcat -4 -N ${ecotank} 9100; }
# uncomment next line to use netcat-nmap
# netsend() { ncat -4 ${ecotank} 9100; }
# uncomment next line to use gnu-netcat
# netsend() { nc -4 -c ${ecotank} 9100; }


# user manual
usage() {
	cat <<~~~
usage: $( basename "$0" ) [-c] [-C] ecotank
argument:
 ecotank is the address or name of the printer
options:
 -c prints a nozzle check page before cleaning
 -C starts cleaning the nozzles without a prior check page
 -q ignore the last cleaning
~~~
	exit 1
}


# global variables
quiet=""
force_check=""
force_clean=""
ecotank=""


# option processing
while getopts ":cCq" option
do
	case $option in
		c) force_check="yes";;
		C) force_clean="yes";;
		q) quiet="yes";;
		\?) usage;;
	esac
done
shift $(( $OPTIND - 1 ))
[[ $# -eq 0 ]] && echo "error: printer address required" >&2 && usage
[[ $# -gt 1 ]] && echo "error: too many arguments" >&2 && usage
ecotank="$1"


# simple connectivity test
if ! ping -4 -c 1 -w 3 ${ecotank} &>/dev/null
then
	echo "error: ${ecotank} is not responding to ping" >&2
	exit 1
fi


# check page before possible cleaning
readonly data_check="AAAAGwFARUpMIDEyODQuNApARUpMICAgICAKG0AbQBsoUggAAFJFTU9URTFUSQgAAAfoCB4HOQ9KUwQAAAAAAE5DAgAAABsAAAANCg0KGyhSCAAAUkVNT1RFMVZJAgAAAExEAAAbAAAADBtAG0AbKFIIAABSRU1PVEUxSkUBAAAbAAAA"
if [ ! "$force_clean" ]
then

	(
		[ "$force_check" ] || read -sp "print a nozzle check page ? "
		base64 -d <<< "$data_check" | netsend
		echo $'\n'"page printing : please wait..."
		sleep 20s
	)

fi


# warn on last cleanup
now=$( date +%s )
last=$( stat -c%Y "$0" )
[ ! "$quiet" ] && [ $(( now - last )) -lt 2592000 ] && read -sp "last cleaning is less than a month ago: continue ? " && echo


# print heads cleaning and check page
readonly data_clean="AAAAGwFARUpMIDEyODQuNApARUpMICAgICAKG0AbQBsoUggAAFJFTU9URTFUSQgAAAfoCB4HOgZDSAIAAAAbAAAA"
[ "$force_clean" ] || read -sp "clean the print nozzles ? "
echo $'\n'"cleaning in progress : please wait..."
echo "(a nozzle check page will be printed after cleaning)"
base64 -d <<< "$data_clean" | netsend
base64 -d <<< "$data_check" | netsend


# set the last cleanup
touch "$0" &>/dev/null
